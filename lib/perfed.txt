@name 
@inputs 
@outputs 
@persist BlockTables:table
@trigger 

#[ Structure of PerfedTables
    {
        "perfname" => {
            "done" => 0 or 1 flag indicating if work for that perf is done
            "values" => returns a table that the calling function should use to persist state
            "first" => 0 or 1 flag indicating if this is the first call to the perfedBlock
    }
]#

#[ Expected function useage
    
    if (perfedBlock("uniquenameforblock")){
        Vars = perfedValues("uniquenameforblock")
        if (perfedBlockFirst("uniquenameforblock")){
            some setup maybe init some values like
            Vars["i", number] = 1
        }
        
        for(I = Vars["i", number], 10){
            do some stuff
            
            if (perfBreak()){
                Vars["i", number] = I
                exit
            }else{
                Vars["i", number] = 1 #not important here but if this was a nested loop it could be
            }
        }
        point at which perfedBlockLast becomes determinite
        
        if (perfedBlockLast("uniquenameforblock")){
            do some cleanup and maybe set final values (like a return)
        }else{
            exit #if it's not the last block we broke for performance reasons so maybe exit here
        }
    }else{
        perfedValues("uniquenameforblock")["whatevervaluewasthegoal", type]
    }
]#

if (first()){
    BlockTables = table()
    
    function table blockTable(Id:string){
        return BlockTables[Id, table]
    }
    
    function number table:blockNotDone(){
        return !This["done", number]
    }
    
    function table:blockDone(N:number){
        This["done", number] = N
    }
    
    #inits and records the iteration of the block #expected to be called exactly once per block execution
    function table block(Id:string){
        if (BlockTables:exists(Id)){
            local BlockTable = blockTable(Id)
            
            if (BlockTable:blockNotDone()){
                BlockTable["exec_number", number] = BlockTable["exec_number", number] + 1
            }
            return BlockTable
        }else{
            local BlockTable = table()
            BlockTable["done", number] = 0
            BlockTable["values", table] = table()
            BlockTable["exec_number", number] = 0
            BlockTables[Id, table] = BlockTable
            
            return BlockTable
        }
    }
    
    function table table:blockValues(){
        return This["values", table]
    }
    
    function number table:blockPerfBreak(N:number){
        if (perf(N)){
            This["done", number] = 1
        }else{
            This["done", number] = 0
        }
        
        return This:blockNotDone()
    }
    function number table:blockPerfBreak(){
        return This:blockPerfBreak(80)
    }
    
    function number table:blockFirst(){
        return (This["exec_number", number] == 0)
    }
    
    function number table:blockLast(){
        return This["done", number]
    }
    
    
    function table blockReset(Id:string){
        BlockTables:remove(Id)
        return block(Id)
    }
    
    function blockResetAll(){
        BlockTables:clear()
    }
}


